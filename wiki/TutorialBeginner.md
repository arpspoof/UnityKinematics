## Step by step tutorial - Beginner

### Step 1: Build
If you havn't done so, please go through [build instructions for Linux](Build.md#Linux) or [build instructions for Windows](Build.md#Windows) here to set up the project. Build output will usually be ```build``` folder on Linux and ```out\build\x64-Release``` on Windows. Here are some useful build assets generated by the build process where you can find in the build folder.
+ ```pyUnityRenderer``` folder: This folder contains python client API which we shall be using later.
+ ```Assets``` folder: This folder contains additional scripts and resources needed by Unity server.

### Step 2: Create the Server: Your Unity Project
#### Prerequisite
+ Unity Editor (Linux / Windows) (Please upgrade to newest version, at least 2019.2).

#### Setup
+ Create an empty unity project (3d).
+ Copy every thing in the ```Assets``` folder generated from build process to the ```Assets``` folder of the unity project.
+ Open Unity Editor.
+ Delete the default 'Sample Scene' and create a new one. (Don't ignore this step).
+ Create and empty GameObject, rename it to 'Controller' (does not matter).
+ Drag script ```KinematicsServer.cs``` from Scripts folder to this object.
+ Now the Unity rendering server is ready to use! It's ugly now and we shall discuss how to customize it later.

### Step 3: Client Side Tutorial

Let's go through some concepts first. A *client* is a program to **provide kinematic data**. In other words, whenever we need to render a new frame, the client must tell where objects are in the scene. 

#### Describing state of an object
To tell Unity where to render an object, we need to tell Unity the position and orientation of the object. Here let's assume that the object is already create in a Unity scene, and the client is just telling Unity about its state.

The state of an object is described by its **global** position and orientation (quaternion) in a normal **right-handed** coordinate system. Refer to [Coordinate Transform](CoordinateTransform.md) page for discussions of different coordinate systems involved. We use structure ```ObjectState``` to describe the state of an object. For example, in Python, we can do the following to create an ```ObjectState``` structure:
```python
objState = ObjectState(objectName, x, y, z, qw, qx, qy, qz)
``` 
Here ```objectName``` is the name of the object. This must be the same as the name of the corresponding ```GameObject``` in Unity.

To this point, we should note that on client side, we only care about position and orientation of an object. All rendering related properties should be taken care of on Unity server side, like sizes, meshes, textures, etc. A common approach is that we create objects in Unity in advance, giving them fancy meshes and textures, and then we use client side program to control how these objects should move. Later we'll see that if we only want to use primitive objects (box, capsule and sphere), we can create these objects through client side commands thus we don't need to create them on Unity side in advance. However, this will still require changing textures and material properties on Unity side. 

#### Groups and state of a group
Here we define a group to be a container of objects. In Unity, a group acts like the parent object of serveral other objects belong to this group. Objects in different groups may share a same name without confusion. A group also has a name and we should use different names for different groups.

The state of a group is determined by states of all objects inside the group (We don't care about positions of orientations of group containers themselves). This correspond to a ```GroupState``` structure. To initialize it, we use the following:
```python
groupState = GroupState(groupName)
groupState.objectStates.push_back(ObjectState("obj1", 1, 2, 3, 1, 0, 0, 0))
groupState.objectStates.push_back(ObjectState("obj2", 4, 5, 6, 1, 0, 0, 0))
...
```
Here ```groupName``` is the name of the group. This must be the same as the name of the corresponding group container ```GameObject``` in Unity. The above code must correspond to the case in Unity where a container with name ```groupName``` has at least two child objects with name ```"obj1"``` and ```"obj2"``` correspondingly. 

#### Frames and state of a frame
To describe what the scene looks like in a specific frame, we need to tell Unity transforms of all objects in the scene. This corresponds to a ```FrameState``` structure. Since we use *groups* to contain objects, we just have a set of ```GroupState``` structures inside a ```FrameState``` structure. The code looks like the following:
```python
frameState = FrameState()
frameState.groups.push_back(group1)
frameState.groups.push_back(group2)
...
```

----

Now let's talk about how to start the client and how to transmit data from the client to the server. We shall go through a complete example in which we will move a cube along a straight line.

Before we write code on the client side, let's create the object to be controller in Unity. Open the Unity project in *Step 2*, create an empty GameObject, named "TestGroup". Then create a cube object named "Cube" under "TestGroup". Note that we are going to refer to these names in the client side program.

To set up client side, we can create a workspace folder at anywhere first. And then copy ```pyUnityRenderer.py```, ```_pyUnityRenderer.pyd``` or ```_pyUnityRenderer.so``` from ```pyUnityRenderer``` folder of the build results to our workspace folder. Then create a Python file named ```test.py``` in our workspace. The first line to be put into the file is:
```python
from pyUnityRenderer import *
```
#### Establish a data provider
In the API provided, we have defined a class called ```AbstractDataProvider```. It has only one abstract function to be implemented, namely ```GetCurrentState```. This function is used as a call back function when the system needs to send the kinematic data to the server. Therefore, in this function, we need to provide what the frame looks like. In other words, we need to construct and return a ```FrameState``` Object. Here we should create a class called ```DataProvider``` which will inherit from ```AbstractDataProvider```. 
```python
class DataProvider(AbstractDataProvider):
    def __init__(self):
        AbstractDataProvider.__init__(self)
        self.x = 0

    def GetCurrentState(self):
        frameState = FrameState()
        frameState.groups.push_back(GroupState("TestGroup"))
        firstGroup = frameState.groups[0]
        firstGroup.objectStates.push_back(ObjectState("Cube", self.x, 2, self.x, 1, 0, 0, 0))
        return frameState

dataProvider = DataProvider()
```
In our system implementation, ```GetCurrentState``` will be called at certain scheduled physical time point (depends on some FPS adjustment technique). Physical time point is not measured by the real timing. It's controled via the ```Tick``` function. You should call this function to drive physical time forward for a certain duration. When such physical time accumulates to some special points, the system will call ```GetCurrentState``` and send the frame data to the server. As a common example for physics simulators, suppose the simulation time step is 1/600s and suppose our render frequency is 60Hz. In this case, we shall call ```Tick(1.0 / 600.0)``` for every simulated frame. Not every call will trigger a ```GetCurrentState```. Instead, in order to render the animation in a normal speed in this case, ```GetCurrentState``` will be called every 10 calls to ```Tick```. If we would like to see a 5x slowed down motion (will be discussed in FPS control usage in later tutorials), then ```GetCurrentState``` will be called every 2 calls to ```Tick```.

#### Establish a command handler
We haven't introduce the command system and what is a command handler yet. Please look up for these material in page [Command System](CommandSystem.md)
. In fact, here we just need a dummy one.
```python
class CommandHandler(AbstractCommandHandler):
    def HandleCommand(self, cmd):
        pass

commandHandler = CommandHandler()
```

#### Initialize the client 
We should always initialize the client before performing any actual operations. This must be done via the ```InitRenderController``` function. This function takes 8 arguments:
+ _serverAddr_: IP address of the remote server.
+ _serverPort_: Running port of the remote server.
+ _localAddr_: IP address of this local machine. This IP address should be accessible by the remote server. If the client and the server are in different LANs, this will be a little bit complicated but in general, techniques like upnp port forwarding will help. If indeed this address is not accessible by the server, some functionalities like FPS control will not work. 
+ _commandHandlingPort_: Specify an arbitrary available port on this local machine for remote command handling. If this is not set up correctly, some functionalities like FPS control will not work.
+ _maxPhysicalFPS_: This specifies how many physical frames can have in one physical second. As an example for simulators, if the simulation is running in constant time step, just set this to ```int(1.0 / timeStep)``` (it has to be an integer). 
+ _dataProvider_: An instance to a data provider.
+ _commandHandler_: An instance to a command handler. 
+ _rpcTimeout_: Timeout value for any netword call. Default is 2000ms. Any network call not responded after this limit will be cancelled. Please adjust this value according to your network transmission speed. 

A sample call looks like:
```python
InitRenderController("localhost", 8080, "localhost", 8081, 1000, dataProvider, commandHandler)
```

#### Driving the time forward
The client side should constantly producing frames and driving physical time forward. Whenever a frame of data is ready, we should call ```Tick``` immediately. Note that we have flow control technique in place so we don't need to worry that the loop will overflow the server. It takes only one argument which is the physical time step of the frame. In our example:
```python
while True:
    dataProvider.x += 0.001
    Tick(0.001)
```
Here we use variable ```x``` to 'move' the object. In every frame with duration 0.001 seconds, we move the object by 0.001 meters along the axis. This will result in a 1m/s movement of the cube. 

#### Notes
+ Always start your server before running client. Otherwise the client may have trouble connecting the server.
+ Make sure you call ```Tick``` for each data frame, otherwise some features will work randomly.

-----
Till this point, if everythings is done properly, you should be able to see something like the screenshot below.
![Screenshot from 2020-01-24 12-18-30](https://user-images.githubusercontent.com/37004963/73101051-b70e9900-3ea3-11ea-9408-da1720413b99.png)

#### Create primitive objects from the client
It's perhaps more convenient to create directly primitive objects via client side commands so we don't need to create the objects and groups manually in Unity. For now we support 3 kinds of primitive objects to be created via client side command: sphere, capsule and box. Let's try this step by step. First, let's delete the group named ```TestGroup``` in Unity first, and later on we'll try to create the Cube on client side directly. On client side, the API name is ```CreatePrimitive``` which looks like:
```python 
CreatePrimitive(primitiveType, groupName, objectName, param0, param1, param2)
```
The meaning of the arguments are listed in the following:
+ _primitiveType_: "box", "sphere", or "capsule".
+ _groupName_: Specify which group shall we put the object in. If the group does not correspond to any GameObject on Unity side, an empty group container will be created automatically.
+ _objectName_: Give a name to the object. If a GameObject with the same name already exists under group ```groupName``` in Unity, the original object will be replaced by this new one.
+ _param0_: 
  + Length along x-axis for box.
  + Radius for sphere.
  + Radius for capsule.
+ _param1_:
  + Length along y-axis for box.
  + Unused for sphere.
  + Length for capsule.
+ _param2_:
  + Length along z-axis for box.
  + Unused for sphere.
  + Unused for capsule.

#### Full code snippet with client side primitive object creation
```python
from pyUnityRenderer import *

class DataProvider(AbstractDataProvider):
    def __init__(self):
        AbstractDataProvider.__init__(self)
        self.x = 0

    def GetCurrentState(self):
        frameState = FrameState()
        frameState.groups.push_back(GroupState("TestGroup"))
        firstGroup = frameState.groups[0]
        firstGroup.objectStates.push_back(ObjectState("Cube", self.x, 2, self.x, 1, 0, 0, 0))
        return frameState

dataProvider = DataProvider()

class CommandHandler(AbstractCommandHandler):
    def HandleCommand(self, cmd):
        pass

commandHandler = CommandHandler()

InitRenderController("localhost", 8080, "localhost", 8081, 1000, dataProvider, commandHandler)
CreatePrimitive("box", "TestGroup", "Cube", 0.5, 1, 1.5)

while True:
    dataProvider.x += 0.001
    Tick(0.001)
```

#### Change primitive object textures / materials
If you run the above code, you'll see a moving box with wooden texture (default one). This can be changed to an arbitrary Unity material. Several simple steps are needed for this.
+ Create a new material in Unity of your choice. 
+ Go to Controller -> Kinematics Server -> General Settings -> Registered Materials, increment the size. A new element entry will show up. Enter the group name which will use this material in the ```Name``` entry. Drag the created material to the ```Material``` slot.

Now if you run again the program, you will see the cube will be rendered using your own created material.

#### Other notes
+ If you would like to use a C++ client, please refer to [C++ client](CppClient.md) page for additional set up instructions. 
+ See [API list](ClientAPI.md) for API prototypes.
